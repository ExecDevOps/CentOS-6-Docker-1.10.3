Nyare Kernel
============

http://www.pangxie.space/docker/364
http://www.pangxie.space/docker/353

Eftersom CentOS 6.7 har för gammal kernel så stöds endast Docker upp till och
med version 1.7.1. Vill man ha högre version så måste först en nyare kernel
installeras och användas:

	# yum install -y --nogpgcheck http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm
	# sed -i -e "s/^\(installonly_limit\) *=.*$/\1=2/g" /etc/yum.conf
	# yum --enablerepo=elrepo-kernel -y install kernel-ml kernel-ml-devel
	# sed -ie "s/^default=1$/default=0/" /boot/grub/grub.conf
	# sed -ie "s/^\(DEFAULTKERNEL\) *=.*$/\1=kernel-ml/g" /etc/sysconfig/kernel
	# reboot



AUFS
====

Vill man ha stöd för AUFS så måste en annan kernel installeras, lägg till repo
för både "long-term" (lt) och "mainline" (ml) kernelvarianterna:
https://git.spaceduck.org/bnied/kernel-lt-aufs

	# wget https://yum.spaceduck.org/kernel-lt-aufs/kernel-lt-aufs.repo -O /etc/yum.repos.d/kernel-lt-aufs.repo
	# wget https://yum.spaceduck.org/kernel-ml-aufs/kernel-ml-aufs.repo -O /etc/yum.repos.d/kernel-ml-aufs.repo


Ställ in att systemet automatiskt sätter denna kernelvariant som default i GRUB:

	# sed -i -e "s/^\(DEFAULTKERNEL\) *=.*$/\1=kernel-ml-aufs/g" /etc/sysconfig/kernel


Installera kernel med stöd för AUFS, byt ut "-ml-" mot "-lt" för long-term support
kernel som då är äldre men kanske stabilare än senaste mainline kerneln:

	# yum --nogpgcheck -y install kernel-ml-aufs kernel-ml-aufs-devel
	# reboot



Devicemapper
============

Docker lagrar alla images under /var/lib/docker. Lagringsytan för varje container
ansluts av devicemapper via loop-mounts. Detta är helt förkastligt ur prestanda-
synpunkt och måste snarast göras om till LVM baserat. Lämpligast är det på en
separat (snabb!) disk, vid start av docker formatteras den till XFS. Ta bort ev.
befintlig data, OBS! detta raderar alla eventuella/befintliga containers!

	# rm -rf /var/lib/docker


Skapa fysisk volym av disken och en volymgrupp samt lägg till den i gruppen:

	# wipefs -a /dev/xvdb
	# pvcreate /dev/xvdb
	# vgcreate vg_docker /dev/xvdb


Skapa logisk volym där docker ska lagra data respektive metadata:

	# lvcreate --wipesignatures y -l 100%FREE -n lv_pool vg_docker


Beskåda underverket:

	# lvs
	# lsblk
	# dmsetup table



BTRFS
=====

Kanske mest lämplig att användas för Docker? Nyare kernel har stabil version
men däremot så är verktygen i usermode föråldrade och måste uppdateras:

	# wget -r -t1 --no-parent --no-host-directories --cut-dirs=4 --ignore-case -R *.html* http://nas.ringv.se/repos/CentOS/6/root/btrfs-progs/ -P /


Kopiera filerna till rätt ställe:

	# cd btrfs-progs
	# chmod +x fsck.btrfs btrfs mkfs.btrfs btrfs-debug-tree btrfs-map-logical btrfs-image btrfs-zero-log btrfs-find-root btrfstune btrfs-show-super btrfs-select-super btrfs-convert btrfs-calc-size libbtrfs.so.0.1

	# install -c -m755 -d /usr/local/bin
	# install -c btrfs mkfs.btrfs fsck.btrfs btrfs-debug-tree btrfs-map-logical btrfs-image btrfs-zero-log btrfs-find-root btrfstune btrfs-show-super btrfs-select-super btrfs-convert /usr/local/bin
	# ln -s -f btrfs /usr/local/bin/btrfsck

	# install -c -m755 -d /usr/local/lib
	# install -c libbtrfs.so.0.1 libbtrfs.a /usr/local/lib
	# ln -s libbtrfs.so.0.1 ./libbtrfs.so.0
	# ln -s libbtrfs.so.0.1 ./libbtrfs.so
	# cp -a libbtrfs.so.0 libbtrfs.so /usr/local/lib


Disken måste mountas där Docker lagrar alla images.  Ta bort ev. befintlig
data, OBS! detta raderar alla eventuella/befintliga containers!

	# rm -rf /var/lib/docker


Skapa filsystemet på disken:

	# mkfs.btrfs --force --metadata dup --label dockerpool /dev/xvdb


Se till att filsystemet mountas automagiskt i samband med systemstart:

	# blkid /dev/xvdb
	# echo $(blkid /dev/xvdb | cut -d " " -f 2) /var/lib/docker btrfs defaults 0 0 >> /etc/fstab


Mounta filsystemet:

	# mkdir /var/lib/docker
	# mount -a



Docker
======

När den nyare kerneln är installerad och används så kan nyare Docker (1.10.3)
installeras:

	# curl -SL -O https://get.docker.com/builds/Linux/x86_64/docker-latest
	# chmod +x docker-latest
	# mv docker-latest /usr/local/bin/docker
	# cp /usr/local/bin/docker /usr/bin/docker


Man ska nu kunna starta Docker som en daemon och se ifall den ger felmeddelanden.
OBS! Om man använder devicemapper måste den logiska volym som skapades ovan anges!

	# docker daemon --storage-driver=aufs
eller
	# docker daemon --storage-driver=devicemapper --storage-opt dm.fs=xfs --storage-opt dm.thinpooldev=/dev/vg_docker/lv_pool --storage-opt dm.use_deferred_removal=true
eller
	# docker daemon --storage-driver=btrfs


Antingen skapar man ett initscript som startar docker i samband med systemstart:

	# nano /etc/rc.local

	#!/bin/sh
	touch /var/lock/subsys/local
	/usr/local/bin/docker daemon --storage-driver=devicemapper --storage-opt dm.fs=xfs --storage-opt dm.thinpooldev=/dev/vg_docker/lv_pool dm.use_deferred_removal=true


Eller ännu bättre är ett riktigt initscript som kör docker som en tjänst:

	# nano /etc/init.d/docker

	#!/bin/sh
	#
	#       /etc/rc.d/init.d/docker
	#
	#       Daemon for docker.com
	#
	# chkconfig:   2345 95 95
	# description: Daemon for docker.com

	### BEGIN INIT INFO
	# Provides:       docker
	# Required-Start: $network cgconfig
	# Required-Stop:
	# Should-Start:
	# Should-Stop:
	# Default-Start: 2 3 4 5
	# Default-Stop:  0 1 6
	# Short-Description: start and stop docker
	# Description: Daemon for docker.com
	### END INIT INFO

	# Source function library.
	. /etc/rc.d/init.d/functions

	prog="docker"
	unshare=/usr/bin/unshare
	exec="/usr/bin/$prog"
	pidfile="/var/run/$prog.pid"
	lockfile="/var/lock/subsys/$prog"
	logfile="/var/log/$prog"

	[ -e /etc/sysconfig/$prog ] && . /etc/sysconfig/$prog

	prestart() {
	    service cgconfig status > /dev/null

	    if [[ $? != 0 ]]; then
		service cgconfig start
	    fi

	}

	start() {
	    [ -x $exec ] || exit 5

	    check_for_cleanup

	    if ! [ -f $pidfile ]; then
		prestart
		printf "Starting $prog:\t"
		echo "\n$(date)\n" >> $logfile
		"$unshare" -m -- $exec daemon $other_args &>> $logfile &
		pid=$!
		touch $lockfile
		# wait up to 10 seconds for the pidfile to exist.  see
		# https://github.com/docker/docker/issues/5359
		tries=0
		while [ ! -f $pidfile -a $tries -lt 10 ]; do
		    sleep 1
		    tries=$((tries + 1))
		done
		success
		echo
	    else
		failure
		echo
		printf "$pidfile still exists...\n"
		exit 7
	    fi
	}

	stop() {
	    echo -n $"Stopping $prog: "
	    killproc -p $pidfile -d 300 $prog
	    retval=$?
	    echo
	    [ $retval -eq 0 ] && rm -f $lockfile
	    return $retval
	}

	restart() {
	    stop
	    start
	}

	reload() {
	    restart
	}

	force_reload() {
	    restart
	}

	rh_status() {
	    status -p $pidfile $prog
	}

	rh_status_q() {
	    rh_status >/dev/null 2>&1
	}


	check_for_cleanup() {
	    if [ -f ${pidfile} ]; then
		/bin/ps -fp $(cat ${pidfile}) > /dev/null || rm ${pidfile}
	    fi
	}

	case "$1" in
	    start)
		rh_status_q && exit 0
		$1
		;;
	    stop)
		rh_status_q || exit 0
		$1
		;;
	    restart)
		$1
		;;
	    reload)
		rh_status_q || exit 7
		$1
		;;
	    force-reload)
		force_reload
		;;
	    status)
		rh_status
		;;
	    condrestart|try-restart)
		rh_status_q || exit 0
		restart
		;;
	    *)
		echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
		exit 2
	esac

	exit $?


Gör startscriptet körbart och installera den som en tjänst samt starta tjänsten:

	# chmod +x /etc/init.d/docker
	# chkconfig --add docker
	# chkconfig docker on
	# service docker start


Skapa en konfigurationsfil som innehåller startupparametrar för tjänsten, dessa
läses in av startscriptet. OBS! Om man använder devicemapper måste den logiska
volym som skapades ovan anges! BTRFS klarar inte SELinux.

	# echo "other_args=\"--selinux-enabled --storage-driver=aufs\"" > /etc/sysconfig/docker
eller
	# echo "other_args=\"--selinux-enabled --storage-driver=devicemapper --storage-opt dm.fs=xfs --storage-opt dm.thinpooldev=/dev/vg_docker/lv_pool dm.use_deferred_removal=true\"" > /etc/sysconfig/docker
eller
	# echo "other_args=\"--storage-driver=btrfs\"" > /etc/sysconfig/docker


Komplettera iptables med en kedja för docker annars kommer containers som vill
modifiera iptables inte kunna installera sig:

	# nano /etc/sysconfig/iptables

	*nat
	:PREROUTING ACCEPT [0:0]
	:INPUT ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	:POSTROUTING ACCEPT [0:0]
	:DOCKER - [0:0]
	-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
	-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
	-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
	COMMIT
	*filter
	:INPUT ACCEPT [0:0]
	:FORWARD ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	:DOCKER - [0:0]
	-A FORWARD -o docker0 -j DOCKER
	-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
	-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
	-A FORWARD -i docker0 -o docker0 -j ACCEPT
	COMMIT


Original ser den ut såhär:

	# nano /etc/sysconfig/iptables

	*filter
	:INPUT ACCEPT [0:0]
	:FORWARD ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
	-A INPUT -p icmp -j ACCEPT
	-A INPUT -i lo -j ACCEPT
	-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
	-A INPUT -m state --state NEW -m udp -p udp --dport 123 -j ACCEPT
	-A INPUT -m state --state NEW -m udp -p udp --dport 161 -j ACCEPT
	-A INPUT -j REJECT --reject-with icmp-host-prohibited
	-A FORWARD -j REJECT --reject-with icmp-host-prohibited
	COMMIT


Starta om iptables så att de nya inställningarna tar:

	# service iptables reload


Sätt på IPv4 forwarding och läs in den nya inställningen:

	# sed -i -e "s/^\(net\.ipv4\.ip_forward\) *=.*$/\1 = 1/g" /etc/sysctl.conf
	# sysctl -p


Stäng av autentisering m.h.a. fingeravtryck(?!?!?) för att slippa meddelanden
om "PAM unable to dlopen(/lib64/security/pam_fprintd.so)..." i /var/log/messages;

	# authconfig --disablefingerprint --update


Om man vill använda Docker som en icke-root användare så ska den användaren
läggas till i gruppen "docker". Glöm inte att användaren behöver logga in/ut
för att detta ska ta!

	# usermod -aG docker <användarnamn>


Nu kan man t.ex. installera verktyget Rancher för att hantera docker containers:

	# docker run -d --restart=always -p 8080:8080 rancher/server


Andra Docker-servrar som ska ansluta sig till Rancher måste installera en Rancher
agent. Om Rancher ska köras på en Docker-server som också ska hanteras av Rancher
så ska installationslänken kompletteras med parametern innehållandes IP adress
för Docker-servern: "-e CATTLE_AGENT_IP=192.168.57.222"

	# docker run -e CATTLE_AGENT_IP=192.168.57.222 -d --privileged -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/rancher:/var/lib/rancher rancher/agent:v0.10.0 http://192.168.57.222:8080/v1/scripts/C1ED667EE80664A64115:1458079200000:hX14vmp3LlP8zg4ana6I3REvqM


Kolla version av Docker:

	# docker version


Installera / kör CentOS i en container:

	# docker run -d -ti centos /bin/bash


Lista vilka images man har:

	# docker images


Lista vilka containers som körs:

	# docker ps


Exportera och importera container, för att t.ex byta storage backend:

	# docker save export/server1 > export_server1.tar.gz
	# docker load < export_server1.tar.gz


	# docker save <image> | bzip2 | pv | ssh root@192.168.57.230 'bunzip2 | docker load'



Xenserver Docker management
===========================

Installera nyare version av ncat, den som följer med i CentOS 6 är föråldrad:

	# yum install https://nmap.org/dist/ncat-7.10-1.x86_64.rpm


# docker run -id busybox /bin/sh
# docker run alpine apk --update add python
# docker run alpine apk --update add nodejs



# docker run -e CATTLE_AGENT_IP=192.168.57.222 -d --privileged -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/rancher:/var/lib/rancher rancher/agent:v0.10.0 http://192.168.57.222:8080/v1/scripts/C1ED667EE80664A64115:1458079200000:hX14vmp3LlP8zg4ana6I3REvqM




/etc/defaults/grub to:

GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"





